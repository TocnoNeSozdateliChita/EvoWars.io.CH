var abs = Math.abs
  , floor = Math.floor
  , ceil = Math.ceil
  , round = Math.round
  , max = Math.max
  , min = Math.min;
function Engine() {
    this.displayMode = "",
    this.author = "Pixel Voices Engine. All rights reserved.",
    this.canvas = void 0,
    this.context = void 0,
    this.scaleX = 1,
    this.scaleY = 1,
    this.fontScale = 1,
    this.dynamicCanvas = void 0,
    this.dynamicContext = void 0,
    this.staticCanvas = void 0,
    this.staticCanvasWorkspace1 = void 0,
    this.staticCanvasWorkspace2 = void 0,
    this.staticCanvasObjects = [],
    this.staticContext = void 0,
    this.staticContextWorkspace1 = void 0,
    this.staticContextWorkspace2 = void 0,
    this.staticCanvasOffset = 400,
    this.staticCanvasRenderPosition = {
        x: 0,
        y: 0
    },
    this.staticCanvasRenderOffset = {
        x: 0,
        y: 0,
        restX: 0,
        restY: 0
    },
    this.canvasToImageArr = [],
    this.convertToImageProcessing = 0,
    this.temporaryImages = [],
    this.lastTemporaryImagesCheckTime = 0,
    this.zoom = 1,
    this.originalWidth = 1920,
    this.originalHeight = 1080,
    this.sprites = [],
    this.spritesToDownload = [],
    this.loadedSprites = 0,
    this.gameObjects = [],
    this.mapPaths = [],
    this.needUpdateObjectsArr = [],
    this.gravity = 0,
    this.latency = 0,
    this.maxInterpolateDistanceIgnore = 50,
    this.maxInterpolateDistanceTeleport = 300,
    this.me = void 0,
    this.time = Date.now(),
    this.camera = {
        holdOn: void 0,
        position: {
            x: 0,
            y: 0
        }
    },
    this.gameLoopOPS = 0,
    this.collisionPrecision = 16,
    this.drawColliders = !1,
    this.drawInterpolatePositions = !1,
    this.newObjectId = 1,
    this.newLocalObjectId = -1,
    this.biggestObjectId = 1,
    this.client = !1,
    this.hashMap = void 0,
    this.hashMapRefreshInterval = 100,
    this.hashMapCellWidth = 150,
    this.hashMapCellHeight = 150,
    this.map = {
        width: 0,
        height: 0
    },
    this.onDeleteObject = function(t) {}
    ,
    this.onCreateObject = function(t) {}
    ,
    this.beforeDrawObject = function(t) {}
    ,
    this.afterDrawObject = function(t) {}
    ,
    this.beforeDrawAllObjects = function() {}
    ,
    this.afterDrawAllObjects = function() {}
    ,
    this.drawing = !1,
    this.fps = 0,
    this.fpsTimes = [],
    this.tickNumber = 0,
    this.drawTick = 0,
    this.lightPoints = [],
    this.deltaTime = 0
}
class Vector2 {
    constructor(t, e) {
        this.x = t,
        this.y = e
    }
}
var defaultColliderRectangleOffset = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
};
class GameObject {
    constructor(t, e) {
        this.engine = t,
        this.position = new Vector2(0,0),
        this.moveSpeed = new Vector2(0,0),
        Object.assign(this, e),
        this.moveable && (this.interpolateTo = new Vector2(void 0,void 0),
        this.previousMoveSpeed = new Vector2(void 0,void 0))
    }
}
function roughSizeOfObject(t) {
    var e = []
      , s = function(t) {
        var o = 0;
        if ("boolean" == typeof t)
            o = 4;
        else if ("string" == typeof t)
            o = 2 * t.length;
        else if ("number" == typeof t)
            o = 8;
        else if ("object" == typeof t && -1 === e.indexOf(t))
            for (i in e[e.length] = t,
            t)
                o += 8,
                o += s(t[i]);
        return o
    };
    return s(t)
}
function HashMap(t, e, i, s) {
    this.lastHashMapRefresh = 0,
    this.ready = !0,
    this.width = t,
    this.height = e,
    this.cellSizeWidth = i,
    this.cellSizeHeight = s,
    this.map = [],
    this.retrieveTick = 0,
    this.cellCountX = Math.ceil(t / i),
    this.cellCountY = Math.ceil(e / s),
    this.cellCount = this.cellCountX * this.cellCountY;
    for (var o = 0; o < this.cellCount; o++)
        this.map[o] = []
}
function sortByProperty(t, e) {
    return t.sort((function(t, i) {
        return t[e] - i[e]
    }
    ))
}
function sortBy2Properties(t, e, i) {
    return t.sort((function(t, s) {
        return t[e] - s[e] || t[i] - s[i]
    }
    ))
}
function sortObjectsToCheckCollision(t, e) {
    return e.sort((function(e, i) {
        var s = e.collisionPriority
          , o = i.collisionPriority;
        return s !== o ? o - s : getDistance(t.x, t.y, e.positionCenter.x, e.positionCenter.y) - getDistance(t.x, t.y, i.positionCenter.x, i.positionCenter.y)
    }
    ))
}
if (GameObject.prototype.outlineWeight = 2,
GameObject.prototype.opacity = 1,
GameObject.prototype.interpolateSpeed = .015,
GameObject.prototype.interpolateForceTeleport = !0,
GameObject.prototype.colliderRectangleOffset = defaultColliderRectangleOffset,
GameObject.prototype.zIndex = 0,
GameObject.prototype.gravityOn = !0,
GameObject.prototype.sleep = !1,
GameObject.prototype.isCollider = !0,
GameObject.prototype.updateHierarchy = 255,
GameObject.prototype.retrieveTick = 0,
GameObject.prototype.zIndex = 0,
GameObject.prototype.outline = null,
GameObject.prototype.loadColliders = !0,
GameObject.prototype.drawTick = 0,
GameObject.prototype.createTime = 0,
GameObject.prototype.canSleep = !0,
GameObject.prototype.simulate = !0,
GameObject.prototype.visible = !0,
GameObject.prototype.moveable = !0,
GameObject.prototype.gravityOn = !0,
GameObject.prototype.animationFrame = 0,
GameObject.prototype.width = 0,
GameObject.prototype.height = 0,
GameObject.prototype.deleted = !1,
GameObject.prototype.animations = null,
GameObject.prototype.rotation = 0,
GameObject.prototype.collisionPriority = 0,
GameObject.prototype.getAllPositions = function() {
    return {
        x: this.position.x,
        y: this.position.y,
        center: {
            x: this.position.x + this.width / 2,
            y: this.position.y + this.height / 2
        },
        right: this.position.x + this.width,
        left: this.position.x,
        top: this.position.y + this.height,
        bottom: this.position.y
    }
}
,
Object.defineProperties(GameObject.prototype, {
    positionCenter: {
        get: function() {
            return {
                x: this.position.x + this.width / 2,
                y: this.position.y + this.height / 2
            }
        }
    },
    positionRight: {
        get: function() {
            return this.position.x + this.width
        }
    },
    positionLeft: {
        get: function() {
            return this.position.x
        }
    },
    positionTop: {
        get: function() {
            return this.position.y + this.height
        }
    },
    positionBottom: {
        get: function() {
            return this.position.y
        }
    },
    colliderRectangleCenter: {
        get: function() {
            return {
                x: this.position.x + this.width * (1 - this.colliderRectangleOffset.right - this.colliderRectangleOffset.left) / 2 + this.width * this.colliderRectangleOffset.left,
                y: this.position.y + this.height * (1 - this.colliderRectangleOffset.top - this.colliderRectangleOffset.bottom) / 2 + this.height * this.colliderRectangleOffset.bottom
            }
        }
    }
}),
GameObject.prototype.getColliderRectangle = {
    left: function() {
        return this.position.x + this.width * this.colliderRectangleOffset.left
    },
    right: function() {
        return this.position.x + this.width - this.width * this.colliderRectangleOffset.right
    },
    top: function() {
        return this.position.y + this.height - this.height * this.colliderRectangleOffset.top
    },
    bottom: function() {
        return this.position.y + this.height * this.colliderRectangleOffset.bottom
    },
    center: function() {
        return {
            x: this.position.x + this.width * (1 - this.colliderRectangleOffset.right - this.colliderRectangleOffset.left) / 2 + this.width * this.colliderRectangleOffset.left,
            y: this.position.y + this.height * (1 - this.colliderRectangleOffset.top - this.colliderRectangleOffset.bottom) / 2 + this.height * this.colliderRectangleOffset.bottom
        }
    }
},
GameObject.prototype.addHandler = function(t, e) {
    if (void 0 === e && (e = {}),
    void 0 === e.interval)
        var i = 0;
    else
        i = e.interval;
    if (void 0 === e.ignoreSimulationStop)
        var s = !1;
    else
        s = e.ignoreSimulationStop;
    this.objectHandlers = this.objectHandlers || [];
    var o = this.objectHandlers.length;
    this.objectHandlers[o] = {},
    this.objectHandlers[o].func = t,
    this.objectHandlers[o].interval = i,
    this.objectHandlers[o].ignoreSimulationStop = s,
    this.objectHandlers[o].nextRunTime = 0,
    this.needToBeUpdating()
}
,
GameObject.prototype.addOnScreenHandler = function(t, e) {
    if (void 0 === e && (e = {}),
    void 0 === e.interval)
        var i = 0;
    else
        i = e.interval;
    this.objectOnScreenHandlers = this.objectOnScreenHandlers || [];
    var s = this.objectOnScreenHandlers.length;
    this.objectOnScreenHandlers[s] = {},
    this.objectOnScreenHandlers[s].func = t,
    this.objectOnScreenHandlers[s].interval = i,
    this.objectOnScreenHandlers[s].nextRunTime = 0
}
,
GameObject.prototype.addCollisionOnTrigger = function(t) {
    this.OnCollisionTriggerArr = this.OnCollisionTriggerArr || [];
    var e = this.OnCollisionTriggerArr.length;
    this.OnCollisionTriggerArr[e] = {},
    this.OnCollisionTriggerArr[e].func = t
}
,
GameObject.prototype.addCollisionOnObtain = function(t) {
    this.OnCollisionObtainArr = this.OnCollisionObtainArr || [];
    var e = this.OnCollisionObtainArr.length;
    this.OnCollisionObtainArr[e] = {},
    this.OnCollisionObtainArr[e].func = t
}
,
GameObject.prototype.removeCollisionOnTrigger = function(t) {
    if (this.OnCollisionTriggerArr) {
        var e = this.OnCollisionTriggerArr.indexOf(t);
        -1 !== e && this.OnCollisionTriggerArr.splice(e, 1)
    }
}
,
GameObject.prototype.removeCollisionOnObtain = function(t) {
    if (this.OnCollisionObtainArr) {
        var e = this.OnCollisionObtainArr.indexOf(t);
        -1 !== e && this.OnCollisionObtainArr.splice(e, 1)
    }
}
,
GameObject.prototype.needToBeUpdating = function() {
    if (void 0 !== this.updateInterval) {
        var t = this.engine.needUpdateObjectsArr[this.updateInterval].objects.indexOf(this);
        -1 !== t && this.engine.needUpdateObjectsArr[this.updateInterval].objects.splice(t, 1)
    }
    var e = 0;
    if (!this.simulate && this.objectHandlers && this.objectHandlers.length > 0)
        for (var i = [], s = 0; s < this.objectHandlers.length; s++) {
            var o = this.objectHandlers[s];
            o.ignoreSimulationStop && i.push(o.interval),
            i.length > 0 && (e = findGCD(i))
        }
    else if (!this.moveable && this.objectHandlers && this.objectHandlers.length > 0)
        if (1 == this.objectHandlers.length)
            e = this.objectHandlers[0].interval;
        else {
            for (i = [],
            s = 0; s < this.objectHandlers.length; s++)
                i.push(this.objectHandlers[s].interval);
            e = findGCD(i)
        }
    this.updateInterval = e,
    void 0 === this.engine.needUpdateObjectsArr[e] && (this.engine.needUpdateObjectsArr[e] = {},
    this.engine.needUpdateObjectsArr[e].objects = [],
    this.engine.needUpdateObjectsArr[e].interval = e,
    this.engine.needUpdateObjectsArr[e].nextRunTime = 0),
    this.engine.needUpdateObjectsArr[e].objects.push(this)
}
,
Engine.prototype.init = function() {
    this.hashMap = new HashMap(this.map.width,this.map.height,this.hashMapCellWidth,this.hashMapCellHeight),
    this.client && (window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
        return setTimeout(t, 1e3 / 60)
    }
    ),
    this.client && (navigator && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Mac OS") && (this.macOS = !0),
    this.isFirefoxBrowser = -1 !== navigator.userAgent.indexOf("Firefox"))
}
,
Engine.prototype.initCanvas = function(t, e, i) {
    this.canvas = document.getElementById("canvasGame"),
    this.context = this.canvas.getContext("2d", {
        alpha: !1
    }),
    this.canvas.addEventListener("mousemove", (function(t) {
        var e = this.getBoundingClientRect();
        this.mousePosition = {
            x: t.clientX - e.left,
            y: t.clientY - e.top
        }
    }
    ), !1),
    this.dynamicCanvas = document.createElement("canvas"),
    this.dynamicContext = this.dynamicCanvas.getContext("2d", {
        alpha: !0
    }),
    this.staticCanvasWorkspace1 = document.createElement("canvas"),
    this.staticCanvasWorkspace2 = document.createElement("canvas"),
    this.staticContextWorkspace1 = this.staticCanvasWorkspace1.getContext("2d", {
        alpha: !1
    }),
    this.staticContextWorkspace2 = this.staticCanvasWorkspace2.getContext("2d", {
        alpha: !1
    }),
    this.staticCanvas = this.staticCanvasWorkspace1,
    this.staticContext = this.staticContextWorkspace1,
    this.setCanvasSize(e, i)
}
,
Engine.prototype.setCanvasSize = function(t, e) {
    t <= 0 || e <= 0 || (this.scaleX = t / this.originalWidth,
    this.scaleY = e / this.originalHeight,
    this.fontScale = this.scaleX,
    this.fontScale < .65 && (this.fontScale = .65),
    this.staticCanvasOffset = Math.max(ceil(400 * this.scaleX), ceil(400 * this.scaleY)),
    this.canvas.width = t,
    this.canvas.height = e,
    this.dynamicCanvas.width = t,
    this.dynamicCanvas.height = e,
    this.staticCanvasWorkspace1.width = t + 2 * this.staticCanvasOffset,
    this.staticCanvasWorkspace1.height = e + 2 * this.staticCanvasOffset,
    this.staticCanvasWorkspace2.width = t + 2 * this.staticCanvasOffset,
    this.staticCanvasWorkspace2.height = e + 2 * this.staticCanvasOffset,
    this.staticCanvasRenderOffset.restX = 0,
    this.staticCanvasRenderOffset.restY = 0,
    this.staticCanvasRenderOffset.x = 0,
    this.staticCanvasRenderOffset.y = 0,
    this.staticCanvasRenderPosition.x = 0,
    this.staticCanvasRenderPosition.y = 0,
    this.clearStaticObjects())
}
,
Engine.prototype.clearStaticObjects = function() {
    for (var t = this.staticCanvasObjects.length - 1; t >= 0; t--) {
        this.staticCanvasObjects[t].inStaticCanvas = !1,
        this.staticCanvasObjects.splice(t, 1)
    }
}
,
Engine.prototype.setZoom = function(t) {
    t > 2 && (t = 2),
    t < 1 && (t = 1),
    this.zoom != t && (this.zoom = t,
    this.staticCanvasRenderOffset.restX = 0,
    this.staticCanvasRenderOffset.restY = 0,
    this.staticCanvasRenderOffset.x = 0,
    this.staticCanvasRenderOffset.y = 0,
    this.staticCanvasRenderPosition.x = 0,
    this.staticCanvasRenderPosition.y = 0,
    this.context.save(),
    this.context.fillStyle = "rgba(0,0,0,1)",
    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height),
    this.context.restore(),
    this.staticContext.save(),
    this.staticContext.fillStyle = "rgba(0,0,0,1)",
    this.staticContext.fillRect(0, 0, this.staticCanvas.width, this.staticCanvas.height),
    this.staticContext.restore(),
    this.dynamicContext.clearRect(0, 0, this.dynamicCanvas.width, this.dynamicCanvas.height),
    this.clearStaticObjects())
}
,
Engine.prototype.getMousePosition = function(t) {
    return void 0 === this.canvas.mousePosition ? {
        x: 0,
        y: 0
    } : 1 == t ? {
        x: this.camera.position.x + this.canvas.mousePosition.x - parseInt(this.canvas.style.width) / 2,
        y: this.camera.position.y + this.canvas.mousePosition.y - parseInt(this.canvas.style.height) / 2
    } : this.canvas.mousePosition
}
,
Engine.prototype.fullScreenCanvas = function() {}
,
Engine.prototype.loadSprite = function(t, e, i) {
    return void 0 === this.sprites[t] && (void 0 === i && (i = {}),
    1 == i.dontDownload ? (this.spritesToDownload[t] = [],
    this.spritesToDownload[t].url = e,
    this.spritesToDownload[t].params = i) : this.downloadSprite(t, e, i)),
    this.sprites[t]
}
,
Engine.prototype.downloadSprite = function(t, e, i, s) {
    var o = cdnServer + "sprites/" + e;
    this.sprites[t] = new Image,
    this.sprites[t].crossOrigin = "Anonymous",
    this.sprites[t].loaded = !1,
    this.sprites[t].name = t,
    i.flip && (this.sprites[t].flip = !0),
    this.sprites[t].src = o;
    var n = this;
    this.sprites[t].onload = function() {
        1 == this.flip && !0 !== this.flipped && (n.sprites[t] = n.flipSprite(this),
        n.canvasToImageArr.push(t)),
        n.loadedSprites++,
        this.loaded = !0,
        i.dontDownload && delete n.spritesToDownload[t],
        "function" == typeof s && s(),
        "function" == typeof updateLoadingProgress && updateLoadingProgress(),
        URL.revokeObjectURL(this.src)
    }
    ;
    var a = cdnServer;
    return this.sprites[t].onerror = function() {
        setTimeout((function() {
            if (cdnServers.length > 1) {
                do {
                    var o = cdnServers[Math.floor(Math.random() * cdnServers.length)]
                } while (a == o);
                cdnServer = o,
                console.log("sprite error: " + e + " - downloading again. New cdn:" + cdnServer),
                n.downloadSprite(t, e, i, s)
            }
        }
        ), 1e3)
    }
    ,
    this.sprites[t]
}
,
Engine.prototype.convertSpriteCanvasToImage = function() {
    if (!(this.fps < 50) && 0 != this.canvasToImageArr.length) {
        var t = this.canvasToImageArr[0]
          , e = this.sprites[t];
        e && e instanceof HTMLCanvasElement && (this.convertToImageProcessing++,
        e.toBlob((e => {
            var i = new Image;
            i.crossOrigin = "Anonymous",
            i.src = URL.createObjectURL(e),
            i.name = t,
            i.onload = () => {
                i.loaded = !0;
                let e = this.sprites[t].name
                  , s = this.sprites[t].lastUsed;
                this.sprites[t] = i,
                this.sprites[t].name = e,
                this.sprites[t].lastUsed = s,
                this.convertToImageProcessing--,
                URL.revokeObjectURL(i.src)
            }
        }
        ))),
        this.canvasToImageArr.shift()
    }
}
,
Engine.prototype.flipSprite = function(t) {
    var e = document.createElement("canvas");
    e.width = t.width,
    e.height = t.height;
    var i = e.getContext("2d");
    if (null !== i && t.width > 0 && t.height > 0) {
        var s = t.name;
        i.scale(-1, 1),
        i.imageSmoothingEnabled = !1,
        i.drawImage(t, -t.width, 0),
        (t = e).loaded = !0,
        t.flipped = !0,
        t.flip = !1,
        t.name = s
    }
    return t
}
,
Engine.prototype.loadObjectLazySprites = function(t) {
    if (!0 !== this.objectsDef[t].lazySpritesLoaded && void 0 === this.objectsDef[t].lazySpritesLoaded) {
        this.objectsDef[t].lazySpritesLoaded = !1;
        let r = !1;
        if (this.objectsDef[t].animations)
            for (var e = 0; e < Object.keys(this.objectsDef[t].animations).length; e++)
                for (var i = this.objectsDef[t].animations[Object.keys(this.objectsDef[t].animations)[e]], s = 0; s < Object.keys(i.sprites).length; s++) {
                    var o = i.sprites[Object.keys(i.sprites)[s]];
                    if (void 0 !== this.spritesToDownload[o]) {
                        r = !0;
                        var n = this.spritesToDownload[o]
                          , a = this;
                        this.downloadSprite(o, n.url, n.params, (function() {
                            for (var e = !0, i = 0; i < Object.keys(a.objectsDef[t].animations).length; i++)
                                for (var s = a.objectsDef[t].animations[Object.keys(a.objectsDef[t].animations)[i]], o = 0; o < Object.keys(s.sprites).length; o++) {
                                    var n = s.sprites[Object.keys(s.sprites)[o]];
                                    void 0 !== a.sprites[n] && 1 == a.sprites[n].loaded || (e = !1)
                                }
                            e && (a.objectsDef[t].lazySpritesLoaded = !0)
                        }
                        ))
                    }
                }
        r || (this.objectsDef[t].lazySpritesLoaded = !0)
    }
}
,
Engine.prototype.loadSkin = function(t, e) {
    if (!0 !== this.objectsDef[t].skinsLoaded[e] && void 0 === this.objectsDef[t].skinsLoaded[e]) {
        this.objectsDef[t].skinsLoaded[e] = !1;
        for (var i = 0; i < Object.keys(this.objectsDef[t].animations).length; i++)
            for (var s = this.objectsDef[t].animations[Object.keys(this.objectsDef[t].animations)[i]], o = 0; o < Object.keys(s.sprites).length; o++) {
                var n = s.sprites[Object.keys(s.sprites)[o]];
                if (void 0 !== this.spritesToDownload[n + "_" + e]) {
                    var a = this.spritesToDownload[n + "_" + e]
                      , r = this;
                    this.downloadSprite(n + "_" + e, a.url, a.params, (function() {
                        for (var i = !0, s = 0; s < Object.keys(r.objectsDef[t].animations).length; s++)
                            for (var o = r.objectsDef[t].animations[Object.keys(r.objectsDef[t].animations)[s]], n = 0; n < Object.keys(o.sprites).length; n++) {
                                var a = o.sprites[Object.keys(o.sprites)[n]];
                                void 0 !== r.sprites[a + "_" + e] && 1 == r.sprites[a + "_" + e].loaded || (i = !1)
                            }
                        i && (r.objectsDef[t].skinsLoaded[e] = !0)
                    }
                    ))
                }
            }
    }
}
,
Engine.prototype.clear = function() {
    this.context.save(),
    this.context.fillStyle = "rgba(0,0,0,1)",
    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height),
    this.context.restore(),
    this.dynamicContext.clearRect(0, 0, this.dynamicCanvas.width, this.dynamicCanvas.height)
}
,
Engine.prototype.drawSprite = function(t, e, i, s, o, n) {
    void 0 === n && (n = {}),
    t.lastUsed = this.time;
    var a = n.staticCanvas || !1
      , r = n.fixedDraw || !1;
    if (!(n.opacity <= 0)) {
        var h = n.opacity || 1
          , l = this.getRenderPosition(e, i)
          , c = 0
          , d = 0;
        if (a) {
            p = this.staticContext;
            c = this.staticCanvasOffset + this.staticCanvasRenderOffset.x,
            d = this.staticCanvasOffset - this.staticCanvasRenderOffset.y
        } else
            var p = this.dynamicContext;
        p.save(),
        1 !== h && (p.globalAlpha = h);
        var f = (n.rotation || 0) * Math.PI / 180;
        if (t.width > 0 && t.height > 0)
            if (0 !== f) {
                p.save();
                let e = l.x + c + o * this.scaleX * this.zoom / 2
                  , i = l.y - s * this.scaleY * this.zoom + d + s * this.scaleY * this.zoom / 2;
                p.translate(e, i),
                p.scale(this.scaleX * this.zoom, this.scaleY * this.zoom),
                p.rotate(f),
                p.drawImage(t, -o / 2, -s / 2, o, s),
                p.restore()
            } else
                a || r ? p.drawImage(t, Math.round(l.x + c), Math.round(l.y - s * this.scaleY * this.zoom + d), Math.ceil(o * this.scaleX * this.zoom), Math.ceil(s * this.scaleY * this.zoom)) : p.drawImage(t, l.x + c, l.y - s * this.scaleY * this.zoom + d, o * this.scaleX * this.zoom, s * this.scaleY * this.zoom);
        1 !== h && (p.globalAlpha = 1),
        p.restore()
    }
}
,
Engine.prototype.drawText = function(t, e, i, s, o) {
    if (void 0 === o && (o = 1),
    void 0 === s && (s = {}),
    !(o <= 0)) {
        var n = this.getRenderPosition(e, i);
        for (var a in this.dynamicContext.save(),
        s)
            this.dynamicContext[a] = s[a];
        this.dynamicContext.globalAlpha = o,
        this.dynamicContext.fillText(t, n.x, n.y);
        var r = this.dynamicContext.measureText(t);
        return this.dynamicContext.restore(),
        r
    }
}
,
Engine.prototype.measureText = function(t, e) {
    for (var i in void 0 === e && (e = {}),
    this.dynamicContext.save(),
    e)
        this.dynamicContext[i] = e[i];
    var s = this.dynamicContext.measureText(t);
    return this.dynamicContext.restore(),
    s
}
,
Engine.prototype.createOutlineImage = function(t, e, i, s) {
    if (!t.width || !t.height)
        return null;
    const o = document.createElement("canvas");
    o.width = t.width + 2 * e,
    o.height = t.height + 2 * e;
    const n = o.getContext("2d");
    if (!n)
        return null;
    const a = [-1, 0, 1];
    return a.forEach((i => {
        a.forEach((s => {
            0 === i && 0 === s || n.drawImage(t, e + i * e, e + s * e, t.width, t.height)
        }
        ))
    }
    )),
    n.globalCompositeOperation = "source-in",
    n.fillStyle = i,
    n.fillRect(0, 0, o.width, o.height),
    s && (n.globalCompositeOperation = "source-over",
    n.drawImage(t, e, e)),
    o
}
,
Engine.prototype.createBorderImage = function(t, e) {
    var i = document.createElement("canvas");
    i.width = parseInt(t.width),
    i.height = parseInt(t.height);
    var s = i.getContext("2d");
    if (null != s && t.width > 0 && t.height > 0) {
        s.drawImage(t, 0, 0);
        var o = e.toString(2).padStart(4, "0");
        return s.lineWidth = 2,
        "1" == o[0] && (s.beginPath(),
        s.moveTo(0, 0),
        s.lineTo(t.width, 0),
        s.stroke()),
        "1" == o[1] && (s.beginPath(),
        s.moveTo(t.width, 0),
        s.lineTo(t.width, t.height),
        s.stroke()),
        "1" == o[2] && (s.beginPath(),
        s.moveTo(t.width, t.height),
        s.lineTo(0, t.height),
        s.stroke()),
        "1" == o[3] && (s.beginPath(),
        s.moveTo(0, t.height),
        s.lineTo(0, 0),
        s.stroke()),
        i
    }
    return null
}
,
Engine.prototype.drawCollider = function(t) {
    var e = this.getRenderPosition(t.position.x, t.position.y);
    this.dynamicContext.save(),
    this.dynamicContext.strokeStyle = t.colliderColor || "black",
    this.dynamicContext.strokeRect(e.x + t.colliderRectangleOffset.left * t.width * this.scaleX * this.zoom, e.y + t.colliderRectangleOffset.top * t.height * this.scaleY * this.zoom - t.height * this.scaleY * this.zoom, t.width * this.scaleX * this.zoom * (1 - (t.colliderRectangleOffset.left + t.colliderRectangleOffset.right)), t.height * this.scaleY * this.zoom * (1 - (t.colliderRectangleOffset.top + t.colliderRectangleOffset.bottom))),
    this.dynamicContext.restore(),
    t.colliderColor = "black"
}
,
Engine.prototype.drawArrow = function(t, e, i, s, o, n) {
    var a;
    t = (a = this.getRenderPosition(t, e)).x,
    e = a.y,
    i = (a = this.getRenderPosition(i, s)).x,
    s = a.y;
    var r = 10
      , h = Math.atan2(s - e, i - t);
    this.dynamicContext.save(),
    this.dynamicContext.strokeStyle = n,
    this.dynamicContext.beginPath(),
    this.dynamicContext.moveTo(t, e),
    this.dynamicContext.lineTo(i, s),
    this.dynamicContext.lineWidth = o,
    this.dynamicContext.stroke(),
    this.dynamicContext.beginPath(),
    this.dynamicContext.moveTo(i, s),
    this.dynamicContext.lineTo(i - r * Math.cos(h - Math.PI / 7), s - r * Math.sin(h - Math.PI / 7)),
    this.dynamicContext.lineTo(i - r * Math.cos(h + Math.PI / 7), s - r * Math.sin(h + Math.PI / 7)),
    this.dynamicContext.lineTo(i, s),
    this.dynamicContext.lineTo(i - r * Math.cos(h - Math.PI / 7), s - r * Math.sin(h - Math.PI / 7)),
    this.dynamicContext.stroke(),
    this.dynamicContext.restore()
}
,
Engine.prototype.getRenderPosition = function(t, e) {
    return {
        x: this.canvas.width / 2 - (this.camera.position.x - t) * this.scaleX * this.zoom,
        y: this.canvas.height - (this.canvas.height / 2 - (this.camera.position.y - e) * this.scaleY * this.zoom)
    }
}
,
Engine.prototype.drawObject = function(t, e) {
    if (t.objectOnScreenHandlers) {
        for (var i = 0; i < t.objectOnScreenHandlers.length && !t.deleted; i++)
            t.objectOnScreenHandlers[i].nextRunTime > this.time || (t.objectOnScreenHandlers[i].nextRunTime = this.time + t.objectOnScreenHandlers[i].interval,
            t.objectOnScreenHandlers[i].func(t, t.objectOnScreenHandlers[i].interval));
        if (t.deleted)
            return
    }
    var s = (n = t.animations[t.animation].sprites)[t.animationFrame % n.length];
    if (n.length > 1 && this.updateFrames(t),
    t.skin && 1 == this.objectsDef[t.name].skinsLoaded[t.skin])
        s = s + "_" + t.skin;
    var o = this.sprites[s];
    if ((!o || !o.loaded) && t.animations.none) {
        var n;
        s = (n = t.animations.none.sprites)[t.animationFrame % n.length];
        o = this.sprites[s]
    }
    if (o && o.loaded) {
        opacity = t.opacity;
        var a = t == this.me;
        if (null != t.outline) {
            var r = t.outline
              , h = t.outlineWeight
              , l = !0
              , c = s + "_outline_" + r;
            this.sprites[c] || null != (l = this.createOutlineImage(o, h, r, !0)) && (l.name = c,
            this.sprites[c] = l,
            this.temporaryImages.push(c),
            this.canvasToImageArr.push(c)),
            null != l && this.drawSprite(this.sprites[s + "_outline_" + r], t.position.x - h, t.position.y - h, t.height + 2 * h, t.width + 2 * h, {
                opacity: opacity,
                staticCanvas: e,
                fixedDraw: t.fixedDraw,
                ignoreOffset: a,
                rotation: t.rotation
            })
        } else if (t.border) {
            l = !0;
            this.sprites[s + "_border_" + t.border] || null != (l = this.createBorderImage(o, t.border)) && (this.sprites[s + "_border_" + t.border] = l,
            this.canvasToImageArr.push(s + "_border_" + t.border)),
            null != l && this.drawSprite(this.sprites[s + "_border_" + t.border], t.position.x, t.position.y, t.height, t.width, {
                opacity: opacity,
                staticCanvas: e,
                fixedDraw: t.fixedDraw,
                ignoreOffset: a,
                rotation: t.rotation
            })
        } else
            this.drawSprite(o, t.position.x, t.position.y, t.height, t.width, {
                opacity: opacity,
                staticCanvas: e,
                fixedDraw: t.fixedDraw,
                ignoreOffset: a,
                rotation: t.rotation
            });
        if (null != t.fillColor) {
            h = 0,
            l = !0,
            c = s + "_fillColor_" + (r = t.fillColor);
            if (!this.sprites[c])
                null != (l = this.createOutlineImage(o, 0, r)) && (l.name = c,
                this.sprites[c] = l,
                this.temporaryImages.push(c),
                this.canvasToImageArr.push(c));
            null != l && this.drawSprite(this.sprites[s + "_fillColor_" + r], t.position.x - h, t.position.y - h, t.height + 2 * h, t.width + 2 * h, {
                opacity: t.fillColorOpacity,
                staticCanvas: e,
                fixedDraw: t.fixedDraw,
                ignoreOffset: a,
                rotation: t.rotation
            })
        }
        if (void 0 !== t.lastState && t.lastState != t.animation && (t.lastState = t.animation,
        t.animationFrame = 0),
        e) {
            t.inStaticCanvas = !0,
            this.staticCanvasObjects.push(t);
            for (var d = this.hashMap.retrieve(t), p = 0; p < d.length; p++) {
                var f = d[p];
                if (!0 === f.inStaticCanvas && (f.zIndex > t.zIndex || !0 === t.hasTransparency) && this.doesOverlap(t, f)) {
                    f.inStaticCanvas = !1;
                    var g = this.staticCanvasObjects.indexOf(f);
                    -1 !== g && this.staticCanvasObjects.splice(g, 1)
                }
            }
        }
    }
    this.drawInterpolatePositions && t.moveable && this.drawInterpolatePosition(t)
}
,
Engine.prototype.drawInterpolatePosition = function(t) {
    if (void 0 !== t.interpolateTo.x && void 0 !== t.interpolateTo.y) {
        var e = {
            font: "11pt monospace",
            fillStyle: "black",
            textAlign: "center"
        };
        game.drawText("x", t.interpolateTo.x, t.interpolateTo.y, e, 1)
    }
}
,
Engine.prototype.cloneCanvas = function(t) {
    var e = document.createElement("canvas")
      , i = e.getContext("2d");
    return e.width = t.width,
    e.height = t.height,
    i.imageSmoothingEnabled = !1,
    i.drawImage(t, 0, 0),
    e
}
,
Engine.prototype.deleteTemporaryImages = function() {
    if (this.time - this.lastTemporaryImagesCheckTime > 1e3) {
        this.lastTemporaryImagesCheckTime = this.time;
        for (var t = 0; t < this.temporaryImages.length; t++) {
            var e = this.temporaryImages[t]
              , i = this.sprites[e];
            i ? i.lastUsed < this.time - 6e4 && (this.sprites[e] = null,
            delete this.sprites[e],
            this.temporaryImages.splice(t, 1),
            t--) : (this.temporaryImages.splice(t, 1),
            t--)
        }
    }
}
,
Engine.prototype.drawObjects = function() {
    if (!this.hashMap.ready)
        return;
    if (this.deleteTemporaryImages(),
    void 0 !== this.camera.holdOn) {
        let t = this.camera.holdOn.positionCenter;
        this.camera.position.x = t.x,
        this.camera.position.y = t.y
    }
    var t = (this.camera.position.x - this.staticCanvasRenderPosition.x) * this.scaleX * this.zoom + this.staticCanvasRenderOffset.restX
      , e = (this.camera.position.y - this.staticCanvasRenderPosition.y) * this.scaleY * this.zoom + this.staticCanvasRenderOffset.restY;
    if (abs(t) >= this.staticCanvasOffset / 2 || abs(e) >= this.staticCanvasOffset / 2) {
        var i = t % 1
          , s = e % 1
          , o = this.staticCanvas;
        this.staticCanvas === this.staticCanvasWorkspace1 ? (this.staticCanvas = this.staticCanvasWorkspace2,
        this.staticContext = this.staticContextWorkspace2) : (this.staticCanvas = this.staticCanvasWorkspace1,
        this.staticContext = this.staticContextWorkspace1),
        this.staticContext.save(),
        this.staticContext.imageSmoothingEnabled = !1,
        this.staticContext.drawImage(o, -t, e),
        this.staticContext.restore(),
        this.staticContext.save(),
        this.staticContext.fillStyle = "rgba(0,0,0,1)",
        t <= 0 ? this.staticContext.fillRect(0, 0, ceil(-t), this.staticCanvas.height) : this.staticContext.fillRect(this.staticCanvas.width - ceil(t), 0, ceil(t), this.staticCanvas.height),
        e >= 0 ? this.staticContext.fillRect(0, 0, this.staticCanvas.width, ceil(e)) : this.staticContext.fillRect(0, this.staticCanvas.height - ceil(-e), this.staticCanvas.width, ceil(-e)),
        this.staticContext.restore(),
        i < 0 ? i < -.5 && (i += 1) : i > .5 && (i -= 1),
        s < 0 ? s < -.5 && (s += 1) : s > .5 && (s -= 1),
        this.staticCanvasRenderOffset.restX = i,
        this.staticCanvasRenderOffset.restY = s,
        this.staticCanvasRenderOffset.x = this.staticCanvasRenderOffset.restX,
        this.staticCanvasRenderOffset.y = this.staticCanvasRenderOffset.restY,
        this.staticCanvasRenderPosition.x += this.camera.position.x - this.staticCanvasRenderPosition.x,
        this.staticCanvasRenderPosition.y += this.camera.position.y - this.staticCanvasRenderPosition.y;
        for (var n = this.staticCanvasObjects.length - 1; n >= 0; n--) {
            var a = this.staticCanvasObjects[n];
            this.goesOutScreen(a) && (a.inStaticCanvas = !1,
            this.staticCanvasObjects.splice(n, 1))
        }
    } else
        this.staticCanvasRenderOffset.x = t,
        this.staticCanvasRenderOffset.y = e;
    this.beforeDrawAllObjects();
    var r = this.sortToDraw(this.hashMap.retrieveVisibleByClient(this));
    this.drawTick++,
    this.lightPoints = [];
    for (n = 0; n < r.length; n++) {
        if ((a = r[n]).light && this.lightPoints.push(a),
        this.isVisible(this.camera, a, this.originalWidth / 2, this.originalHeight / 2) && a.visible) {
            var h = !1;
            if (!0 === a.staticCanvas) {
                if (!0 === a.inStaticCanvas)
                    continue;
                h = !0
            }
            this.beforeDrawObject(a, h),
            this.drawObject(a, h),
            this.afterDrawObject(a, h)
        }
    }
    if (this.afterDrawAllObjects(),
    this.drawColliders)
        for (n = 0; n < r.length; n++) {
            (a = r[n]).visible && this.isVisible(this.camera, a, this.originalWidth / 2, this.originalHeight / 2) && a.isCollider && this.drawCollider(a)
        }
    this.context.save(),
    this.context.imageSmoothingEnabled = !1,
    this.context.drawImage(this.staticCanvas, this.staticCanvasOffset + this.staticCanvasRenderOffset.x, this.staticCanvasOffset - this.staticCanvasRenderOffset.y, this.staticCanvas.width - 2 * this.staticCanvasOffset, this.staticCanvas.height - 2 * this.staticCanvasOffset, 0, 0, this.canvas.width, this.canvas.height),
    this.context.drawImage(this.dynamicCanvas, 0, 0),
    this.context.restore();
    const l = Date.now();
    for (; this.fpsTimes.length > 0 && this.fpsTimes[0] <= l - 1e3; )
        this.fpsTimes.shift();
    this.fpsTimes.push(l),
    this.fps = this.fpsTimes.length,
    this.convertToImageProcessing <= 0 && this.convertSpriteCanvasToImage()
}
,
Engine.prototype.doesOverlap = function(t, e) {
    return !(t.position.y + t.height <= e.position.y || t.position.y >= e.position.y + e.height || t.position.x + t.width <= e.position.x || t.position.x >= e.x + e.position.width)
}
,
Engine.prototype.newObject = function(t) {
    return new GameObject(this,t)
}
,
Engine.prototype.addObject = function(t) {
    return void 0 === t.id && (t.id = this.newObjectId++),
    null == t.id && (t.id = this.newLocalObjectId--),
    t.id > this.biggestObjectId && (this.biggestObjectId = t.id),
    t.engine = this,
    t.createTime = this.time,
    this.onCreateObject(t),
    this.gameObjects[t.id] = t,
    this.hashMap.insert(t),
    t
}
,
Engine.prototype.update = function() {
    this.time = Date.now(),
    this.tickNumber++;
    for (var t = 0; t < Object.keys(this.needUpdateObjectsArr).length; t++) {
        var e = Object.keys(this.needUpdateObjectsArr)[t];
        if (!(this.needUpdateObjectsArr[e].nextRunTime > this.time)) {
            if (this.needUpdateObjectsArr[e].nextRunTime = this.time + this.needUpdateObjectsArr[e].interval,
            this.client)
                var i = this.needUpdateObjectsArr[e].objects;
            else
                i = sortByProperty(this.needUpdateObjectsArr[e].objects, "updateHierarchy");
            i = [...i];
            for (var s = 0; s < i.length; s++) {
                var o = i[s]
                  , n = !0;
                if (o.objectHandlers)
                    for (var a = 0; a < o.objectHandlers.length && !o.deleted; a++)
                        (o.simulate || !0 === o.objectHandlers[a].ignoreSimulationStop) && (o.objectHandlers[a].nextRunTime > this.time || (o.objectHandlers[a].nextRunTime = this.time + o.objectHandlers[a].interval,
                        !1 === o.objectHandlers[a].func(o, o.objectHandlers[a].interval) && (n = !1)));
                if (o.simulate && (!o.deleted && n && o.moveable)) {
                    if (o.sleep) {
                        if (0 == o.moveSpeed.x && (-1e-6 == o.moveSpeed.y || 0 == o.moveSpeed.y))
                            continue;
                        o.sleep = !1
                    }
                    this.updateGravity(o),
                    o.physicsSteps = max(1, ceil(abs(o.moveSpeed.x) * this.deltaTime / this.collisionPrecision), ceil(abs(o.moveSpeed.y) * this.deltaTime / this.collisionPrecision)),
                    o.triggeredColliders = [];
                    for (var r = 0; r < o.physicsSteps; r++) {
                        if (o.loadColliders) {
                            o.loadColliders = !1;
                            for (var h = this.hashMap.retrieve(o), l = 0; l < h.length; l++) {
                                if (!(d = h[l]).isCollider || o.id == d.id) {
                                    var c = h.indexOf(d);
                                    if (-1 != c) {
                                        h.splice(c, 1),
                                        l--;
                                        continue
                                    }
                                }
                            }
                            h = sortObjectsToCheckCollision(o.positionCenter, h),
                            o.collidersToCheck = h
                        } else
                            h = o.collidersToCheck;
                        o.groundedBottom = !1,
                        o.groundedTop = !1,
                        o.groundedLeft = !1,
                        o.groundedRight = !1,
                        o.ridingOtherObject > 0 && o.ridingOtherObject--;
                        for (l = 0; l < h.length; l++) {
                            var d;
                            if (!(d = h[l]).deleted) {
                                if (this.checkCollision(o, d)) {
                                    if (o.physicsSteps > 1) {
                                        if (1 == o.triggeredColliders[d.id])
                                            continue;
                                        o.triggeredColliders[d.id] = !0
                                    }
                                    d.moveable && (d.sleep = !1,
                                    d.previousMoveSpeed.x = null,
                                    d.previousMoveSpeed.y = null),
                                    this.collide(o, d)
                                }
                                if (o.deleted)
                                    break
                            }
                        }
                        if (o.deleted)
                            break;
                        this.updatePosition(o),
                        this.hashMap.updateObject(o),
                        !(o.canSleep && !o.sleep && o.ridingOtherObject > 0 && 0 == o.moveSpeed.x) || -1e-6 != o.moveSpeed.y && 0 != o.moveSpeed.y || 0 != o.previousMoveSpeed.x || -1e-6 != o.previousMoveSpeed.y && 0 != o.previousMoveSpeed.y || (o.sleep = !0),
                        o.previousMoveSpeed.x = o.moveSpeed.x,
                        o.previousMoveSpeed.y = o.moveSpeed.y
                    }
                    !this.client || void 0 === o.interpolateTo.x && void 0 === o.interpolateTo.y || this.interpolatePosition(o)
                }
            }
        }
    }
}
,
Engine.prototype.updateFrames = function(t) {
    null == t.lastChangeAnimationFrameTime && (t.lastChangeAnimationFrameTime = this.time),
    void 0 !== t.animations && void 0 !== t.animations[t.animation] && t.animations[t.animation].sprites.length > 1 && t.lastChangeAnimationFrameTime + t.animations[t.animation].animationFrameTime < this.time && (t.animationFrame++,
    t.lastChangeAnimationFrameTime = this.time,
    t.animationFrame >= 2147483647 && (t.animationFrame = 0))
}
,
Engine.prototype.updateGravity = function(t) {
    t.gravityOn && (t.moveSpeed.y -= this.gravity * this.deltaTime)
}
,
Engine.prototype.updatePosition = function(t) {
    t.position.x += t.moveSpeed.x * this.deltaTime / t.physicsSteps,
    t.position.y += t.moveSpeed.y * this.deltaTime / t.physicsSteps
}
,
Engine.prototype.interpolatePosition = function(t) {
    void 0 === t.interpolateTo.x && (t.interpolateTo.x = t.position.x),
    void 0 === t.interpolateTo.y && (t.interpolateTo.y = t.position.y);
    let e = t.maxInterpolateDistanceTeleport || this.maxInterpolateDistanceTeleport;
    t.interpolateForceTeleport && (abs(t.position.x - t.interpolateTo.x) > e || abs(t.position.y - t.interpolateTo.y) > e) ? (t.position.x = t.interpolateTo.x,
    t.position.y = t.interpolateTo.y,
    t == this.me && this.clearStaticObjects()) : (t.position.x = this.getTween(t.position.x, t.interpolateTo.x, t.interpolateSpeed * this.deltaTime * this.gameLoopOPS),
    t.position.y = this.getTween(t.position.y, t.interpolateTo.y, t.interpolateSpeed * this.deltaTime * this.gameLoopOPS)),
    abs(t.position.x - t.interpolateTo.x) < 1 + abs(t.moveSpeed.x) * this.latency / 1e3 && (t.interpolateTo.x = void 0),
    abs(t.position.y - t.interpolateTo.y) < 1 + abs(t.moveSpeed.y) * this.latency / 1e3 && (t.interpolateTo.y = void 0)
}
,
Engine.prototype.getTween = function(t, e, i) {
    return t + i * (e - t)
}
,
Engine.prototype.isCollision2Rectangles = function(t, e) {
    if (t.position.x + t.colliderRectangleOffset.left * t.width > e.position.x + (1 - e.colliderRectangleOffset.right) * e.width)
        return !1;
    var i = t.position.x + (1 - t.colliderRectangleOffset.right) * t.width;
    if (e.position.x + e.colliderRectangleOffset.left * e.width > i)
        return !1;
    if (t.position.y + (1 - t.colliderRectangleOffset.top) * t.height < e.position.y + e.colliderRectangleOffset.bottom * e.height)
        return !1;
    var s = t.position.y + t.colliderRectangleOffset.bottom * t.height;
    return !(e.position.y + (1 - e.colliderRectangleOffset.top) * e.height < s)
}
,
Engine.prototype.checkCollision = function(t, e) {
    return !!(e.isCollider && t.isCollider && this.isCollision2Rectangles(t, e)) && (this.drawColliders && (t.colliderColor = "red",
    e.colliderColor = "red"),
    !0)
}
,
Engine.prototype.collisionOn = {
    TOP: 1,
    RIGHT: 2,
    BOTTOM: 3,
    LEFT: 4
},
Engine.prototype.collide = function(t, e) {
    t.collisionW = t.collisionW || t.width * (1 - (t.colliderRectangleOffset.left + t.colliderRectangleOffset.right)),
    e.collisionW = e.collisionW || e.width * (1 - (e.colliderRectangleOffset.left + e.colliderRectangleOffset.right)),
    t.collisionH = t.collisionH || t.height * (1 - (t.colliderRectangleOffset.top + t.colliderRectangleOffset.bottom)),
    e.collisionH = e.collisionH || e.height * (1 - (e.colliderRectangleOffset.top + e.colliderRectangleOffset.bottom));
    var i = .5 * (t.collisionW + e.collisionW)
      , s = .5 * (t.collisionH + e.collisionH);
    t.collisionDx = t.collisionDx || (t.colliderRectangleOffset.left + (1 - (t.colliderRectangleOffset.left + t.colliderRectangleOffset.right)) / 2) * t.width,
    t.collisionDy = t.collisionDy || (t.colliderRectangleOffset.bottom + (1 - (t.colliderRectangleOffset.bottom + t.colliderRectangleOffset.top)) / 2) * t.height,
    e.collisionDx = e.collisionDx || (e.colliderRectangleOffset.left + (1 - (e.colliderRectangleOffset.left + e.colliderRectangleOffset.right)) / 2) * e.width,
    e.collisionDy = e.collisionDy || (e.colliderRectangleOffset.bottom + (1 - (e.colliderRectangleOffset.bottom + e.colliderRectangleOffset.top)) / 2) * e.height;
    var o = t.position.x + t.collisionDx - (e.position.x + e.collisionDx)
      , n = t.position.y + t.collisionDy - (e.position.y + e.collisionDy);
    if (abs(o) < i && abs(n) < s) {
        var a = i * n
          , r = s * o;
        if (a > r)
            if (a > -r) {
                if (!this.onCollide(t, e, this.collisionOn.BOTTOM))
                    return;
                if (!0 !== t.cantBePushed && !t.groundedTop) {
                    var h = e.positionTop - (t.colliderRectangleOffset.bottom * t.height + e.colliderRectangleOffset.top * e.height);
                    if (this.client)
                        if (h - (t.interpolateTo.y || h) > this.maxInterpolateDistanceIgnore)
                            return;
                    t.position.y = h
                }
                1 == e.cantBePushed ? t.moveSpeed.y < e.moveSpeed.y && (t.moveSpeed.y = e.moveSpeed.y + 1e-6) : e.groundedBottom && t.moveSpeed.y < 0 ? (t.moveSpeed.y = -1e-6,
                t.groundedBottom = !0) : e.moveable && !e.groundedBottom ? !0 !== t.cantBePushed && (t.moveSpeed.y = (t.moveSpeed.y + e.moveSpeed.y) / 2) : t.moveSpeed.y < 0 && (t.moveSpeed.y = -1e-6,
                t.groundedBottom = !0);
                let i = e.collideMovementReduce || .9;
                t.moveSpeed.x *= i,
                e.groundedBottom && (0 != e.moveSpeed.x || e.ridingOtherObject > 0) && !0 !== t.cantBePushed && (e.ridingOtherObject > 0 ? t.position.x += (e.moveSpeed.x + (e.ridingSpeedX || 0)) * this.deltaTime : t.position.x += e.moveSpeed.x * this.deltaTime,
                t.ridingSpeedX = e.moveSpeed.x + (e.ridingSpeedX || 0),
                t.ridingOtherObject = 2)
            } else {
                if (!this.onCollide(t, e, this.collisionOn.RIGHT))
                    return;
                if ((abs(t.moveSpeed.x) > abs(e.moveSpeed.x) || t.ridingOtherObject > 0) && !t.groundedLeft && !0 !== t.cantBePushed) {
                    h = e.positionLeft + (t.colliderRectangleOffset.right * t.width + e.colliderRectangleOffset.left * e.width) - t.width;
                    if (this.client)
                        if ((t.interpolateTo.x || h) - h > this.maxInterpolateDistanceIgnore)
                            return;
                    t.position.x = h
                }
                1 == e.cantBePushed ? e.moveSpeed.x < 0 && (t.moveSpeed.x = e.moveSpeed.x - 1e-6) : e.groundedRight && t.moveSpeed.x > 0 ? (t.moveSpeed.x = 1e-6,
                t.groundedRight = !0) : e.moveable && !e.groundedRight ? !0 !== t.cantBePushed && (t.moveSpeed.x = (t.moveSpeed.x + e.moveSpeed.x) / 2) : t.moveSpeed.x > 0 && (t.moveSpeed.x = 1e-6,
                t.groundedRight = !0)
            }
        else if (a > -r) {
            if (!this.onCollide(t, e, this.collisionOn.LEFT))
                return;
            if ((abs(t.moveSpeed.x) > abs(e.moveSpeed.x) || t.ridingOtherObject > 0) && !t.groundedRight && !0 !== t.cantBePushed) {
                if (h = e.positionRight - (t.colliderRectangleOffset.left * t.width + e.colliderRectangleOffset.right * e.width),
                this.client)
                    if (h - (t.interpolateTo.x || h) > this.maxInterpolateDistanceIgnore)
                        return;
                t.position.x = h
            }
            1 == e.cantBePushed ? e.moveSpeed.x > 0 && (t.moveSpeed.x = e.moveSpeed.x + 1e-6) : e.groundedLeft && t.moveSpeed.x < 0 ? (t.moveSpeed.x = -1e-6,
            t.groundedLeft = !0) : e.moveable && !e.groundedLeft ? !0 !== t.cantBePushed && (t.moveSpeed.x = (t.moveSpeed.x + e.moveSpeed.x) / 2) : t.moveSpeed.x < 0 && (t.moveSpeed.x = -1e-6,
            t.groundedLeft = !0)
        } else {
            if (!this.onCollide(t, e, this.collisionOn.TOP))
                return;
            if (abs(t.moveSpeed.y) > abs(e.moveSpeed.y) && !0 !== t.cantBePushed && !t.groundedBottom) {
                h = e.positionBottom + (t.colliderRectangleOffset.top * t.height + e.colliderRectangleOffset.bottom * e.height) - t.height;
                if (this.client)
                    if ((t.interpolateTo.y || h) - h > this.maxInterpolateDistanceIgnore)
                        return;
                t.position.y = h
            }
            1 == e.cantBePushed ? t.moveSpeed.y > 0 && (t.moveSpeed.y = e.moveSpeed.y - 1e-6) : e.groundedTop && t.moveSpeed.y > -1e-6 ? (t.moveSpeed.y = 1e-6,
            t.groundedTop = !0) : e.moveable && !e.groundedTop ? !0 !== t.cantBePushed && (t.moveSpeed.y = (t.moveSpeed.y + e.moveSpeed.y) / 2) : t.moveSpeed.y >= -1e-6 && (t.moveSpeed.y = 1e-6,
            t.groundedTop = !0)
        }
    }
}
,
Engine.prototype.onCollide = function(t, e, i) {
    var s = !0;
    if (e.OnCollisionObtainArr)
        for (var o = 0; o < e.OnCollisionObtainArr.length && !e.deleted; o++)
            !1 === e.OnCollisionObtainArr[o].func(e, t, i) && (s = !1);
    if (s && t.OnCollisionTriggerArr)
        for (o = 0; o < t.OnCollisionTriggerArr.length && !t.deleted; o++)
            !1 === t.OnCollisionTriggerArr[o].func(t, e, i) && (s = !1);
    return s
}
,
Engine.prototype.isVisible = function(t, e, i, s) {
    if (i /= this.zoom,
    s /= this.zoom,
    t.position.x >= e.position.x) {
        if (abs(t.position.x - e.position.x) >= i + e.width)
            return !1
    } else if (abs(t.position.x - e.position.x) >= i)
        return !1;
    if (t.position.y >= e.position.y) {
        if (abs(t.position.y - e.position.y) >= s + e.height)
            return !1
    } else if (abs(t.position.y - e.position.y) >= s)
        return !1;
    return !0
}
,
Engine.prototype.goesOutScreen = function(t) {
    if (this.camera.position.x >= t.position.x) {
        if (t.position.x < this.camera.position.x - this.originalWidth / 2 / this.zoom)
            return !0
    } else if (t.position.x + t.width > this.camera.position.x + this.originalWidth / 2 / this.zoom)
        return !0;
    return this.camera.position.y >= t.position.y && t.position.y < this.camera.position.y - this.originalHeight / 2 / this.zoom || t.position.y + t.height > this.camera.position.y + this.originalHeight / 2 / this.zoom
}
,
Engine.prototype.deleteObject = function(t, e) {
    if (!this.client || void 0 !== t) {
        if (void 0 === e ? this.onDeleteObject(t) : this.onDeleteObject(t, e),
        void 0 !== t.updateInterval)
            -1 !== (s = this.needUpdateObjectsArr[t.updateInterval].objects.indexOf(t)) && this.needUpdateObjectsArr[t.updateInterval].objects.splice(s, 1);
        for (var i = 0; i < t.inCells.length; i++) {
            var s, o = this.hashMap.map[t.inCells[i]];
            -1 !== (s = o.indexOf(t)) && o.splice(s, 1);
            for (var n = 0; n < o.length; n++)
                o[n].loadColliders = !0
        }
        delete this.gameObjects[t.id],
        t.collidersToCheck = [],
        t.deleted = !0
    }
}
,
HashMap.prototype.insert = function(t) {
    var e = this.getIndex(t);
    if (t.light) {
        var i = 0;
        t.light_radius && (i = t.light_radius,
        t.light_random_radius && (i += t.light_random_radius));
        var s = parseInt(((t.position.x - i) % this.cellSizeWidth + t.width + 2 * i) / (this.cellSizeWidth + 1e-8)) + 1
          , o = parseInt(((t.position.y - i) % this.cellSizeHeight + t.height + 2 * i) / (this.cellSizeHeight + 1e-8)) + 1
    } else
        s = parseInt((t.position.x % this.cellSizeWidth + t.width) / (this.cellSizeWidth + 1e-8)) + 1,
        o = parseInt((t.position.y % this.cellSizeHeight + t.height) / (this.cellSizeHeight + 1e-8)) + 1;
    t.inCells = [];
    for (var n = 0; n < s; n++) {
        if (e >= 0 && e < this.map.length) {
            (l = this.map[e]).push(t),
            t.inCells.push(e);
            for (var a = 0; a < l.length; a++)
                l[a].loadColliders = !0
        }
        for (var r = e, h = 1; h < o; h++)
            if (r += this.cellCountX,
            this.map[r]) {
                var l;
                (l = this.map[r]).push(t),
                t.inCells.push(r);
                for (a = 0; a < l.length; a++)
                    l[a].loadColliders = !0
            }
        e += 1
    }
}
,
HashMap.prototype.updateObject = function(t) {
    var e = this.getIndex(t);
    if (t.light) {
        var i = 0;
        t.light_radius && (i = t.light_radius,
        t.light_random_radius && (i += t.light_random_radius));
        var s = parseInt(((t.position.x - i) % this.cellSizeWidth + t.width + 2 * i) / (this.cellSizeWidth + 1e-8)) + 1
          , o = parseInt(((t.position.y - i) % this.cellSizeHeight + t.height + 2 * i) / (this.cellSizeHeight + 1e-8)) + 1
    } else
        s = parseInt((t.position.x % this.cellSizeWidth + t.width) / (this.cellSizeWidth + 1e-8)) + 1,
        o = parseInt((t.position.y % this.cellSizeHeight + t.height) / (this.cellSizeHeight + 1e-8)) + 1;
    for (var n = [], a = 0; a < s; a++) {
        n.push(e);
        for (var r = e, h = 1; h < o; h++)
            r += this.cellCountX,
            n.push(r);
        e += 1
    }
    if (n.length !== t.inCells.length || !n.every((function(e, i) {
        return e === t.inCells[i]
    }
    ))) {
        for (a = 0; a < t.inCells.length; a++) {
            -1 !== (e = (c = this.map[t.inCells[a]]).indexOf(t)) && c.splice(e, 1)
        }
        t.inCells = [];
        for (var l = 0; l < n.length; l++)
            if (this.map[n[l]]) {
                var c;
                (c = this.map[n[l]]).push(t),
                t.inCells.push(n[l]);
                for (var d = 0; d < c.length; d++)
                    c[d].loadColliders = !0
            }
    }
}
,
HashMap.prototype.clear = function() {
    for (var t = 0; t < this.cellCount; t++)
        this.map[t] = []
}
,
HashMap.prototype.started = function() {
    this.ready = !1
}
,
HashMap.prototype.done = function() {
    this.ready = !0,
    this.lastHashMapRefresh = Date.now()
}
,
HashMap.prototype.getIndex = function(t) {
    if (t.light) {
        var e = 0;
        return t.light_radius && (e = t.light_radius,
        t.light_random_radius && (e += t.light_random_radius)),
        parseInt((t.position.x - e) / this.cellSizeWidth) + this.cellCountX * parseInt((t.position.y - e) / this.cellSizeHeight)
    }
    return parseInt(t.position.x / this.cellSizeWidth) + this.cellCountX * parseInt(t.position.y / this.cellSizeHeight)
}
,
HashMap.prototype.retrieve = function(t) {
    var e = ++this.retrieveTick
      , i = [];
    if (t.inCells && t.inCells.length > 0)
        for (var s = 0; s < t.inCells.length; s++)
            for (var o = t.inCells[s], n = 0; n < this.map[o].length; n++) {
                (d = this.map[o][n]).retrieveTick != e && (d.retrieveTick = e,
                i[i.length] = d)
            }
    else
        for (var a = this.getIndex(t), r = parseInt((t.position.x % this.cellSizeWidth + t.width) / this.cellSizeWidth) + 1, h = parseInt((t.position.y % this.cellSizeHeight + t.height) / this.cellSizeHeight) + 1, l = 0; l < r; l++)
            for (var c = 0; c < h; c++) {
                if ((o = a + l + c * this.cellCountX) >= 0 && o < this.map.length)
                    for (n = 0; n < this.map[o].length; n++) {
                        var d;
                        (d = this.map[o][n]).retrieveTick != e && (d.retrieveTick = e,
                        i[i.length] = d)
                    }
            }
    return i
}
,
HashMap.prototype.retrieveOnly = function(t, e) {
    for (var i = ++this.retrieveTick, s = this.getIndex(t), o = [], n = parseInt((t.position.x % this.cellSizeWidth + t.width) / this.cellSizeWidth) + 1, a = parseInt((t.position.y % this.cellSizeHeight + t.height) / this.cellSizeHeight) + 1, r = 0; r < n; r++)
        for (var h = 0; h < a; h++) {
            var l = s + r + h * this.cellCountX;
            if (l >= 0 && l < this.map.length)
                for (var c = 0; c < this.map[l].length; c++) {
                    void 0 !== e[(t = this.map[l][c]).id] && 1 != e[t.id] || t.retrieveTick != i && (t.retrieveTick = i,
                    o[o.length] = t)
                }
        }
    return o
}
,
HashMap.prototype.retrieveVisibleByClient = function(t) {
    var e = {
        position: {
            x: t.camera.position.x - t.originalWidth / 2 / t.zoom,
            y: t.camera.position.y - t.originalHeight / 2 / t.zoom
        },
        width: t.originalWidth / t.zoom,
        height: t.originalHeight / t.zoom
    };
    return this.retrieve(e)
}
,
Array.prototype.removeDuplicates = function() {
    return this.filter((function(t, e, i) {
        return i.indexOf(t) == e
    }
    ))
}
,
String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1)
}
,
Engine.prototype.sortToDraw = function(t) {
    var e = this.biggestObjectId;
    return t.sort((function(t, i) {
        return t.zIndex * e + t.id - (i.zIndex * e + i.id)
    }
    ))
}
,
!("undefined" == typeof window || window.performance && window.performance.now)) {
    var start = Date.now();
    window.performance = {
        now: function() {
            return Date.now() - start
        }
    }
}
function randomInteger(t, e) {
    return floor(Math.random() * (e - t + 1)) + t
}
function gcd(t, e) {
    return 0 == t ? t : gcd(e % t, t)
}
function findGCD(t) {
    let e = t[0];
    for (let i = 1; i < t.length; i++)
        if (e = gcd(t[i], e),
        1 == e)
            return 1;
    return e
}
function getDistance(t, e, i, s) {
    let o = i - t
      , n = s - e;
    return Math.sqrt(n * n + o * o)
}
function imageToBase64(t) {
    var e = document.createElement("canvas");
    return e.width = t.width,
    e.height = t.height,
    e.getContext("2d").drawImage(t, 0, 0),
    e.toDataURL("image/png")
}
function isObject(t) {
    return "object" == typeof t && null !== t
}
"undefined" != typeof CanvasRenderingContext2D && (CanvasRenderingContext2D.prototype.roundRect = function(t, e, i, s, o) {
    return i < 2 * o && (o = i / 2),
    s < 2 * o && (o = s / 2),
    this.beginPath(),
    this.moveTo(t + o, e),
    this.arcTo(t + i, e, t + i, e + s, o),
    this.arcTo(t + i, e + s, t, e + s, o),
    this.arcTo(t, e + s, t, e, o),
    this.arcTo(t, e, t + i, e, o),
    this.closePath(),
    this
}
),
Engine.prototype.objectAssign = function(t, ...e) {
    return Object.assign(t, ...e),
    delete t.collisionW,
    delete t.collisionH,
    delete t.collisionDx,
    delete t.collisionDy,
    t
}
;
